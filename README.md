# My Work

Oh, howdy there! 
Glad you made it here.
In this little corner of the internet, I host some the projects I have worked on or are currently working on.
Feel free to contact me for any question using form found at the bottom of my [website](https://oescoba2.github.io.).
I give a breakdown of each directory in this repo and the contents therein in a TL;DR format.

# About Me
I am Oscar J. Escobar and are about to finish the Applied and Computational Mathematics (ACME) degree at Brigham Young University (BYU) this December.
I love football (i.e. soccer) and am a huge fan of Real Madrid.
In my spare time, I like to cook, watch series and movies, play the piano and guitar, and learn new things.


# Modeling_data 
This directory contains some of the projects I have undertaken where I applied ML, Time Series, or deep learning in order to model with data and uncertainty.

# OTC_Dyanmics
This directory contains some of the projects where I modeled using dynamics and then applied optimal control theory (OTC).

# DRL
This directory contains my work in implementing deep reinforcement learning (DRL) in order to learn and apply it.
I am happy to say I authored 

# DA

# Coursework
This directory contains some of the cool homeworks or labs I did as part of the classes I took at BYU.



### HW4_1 (Dynamic Programming Homework, Vol 2)
This was part of written homework when we first discussed dynammic programming (top-down/memoization, bottom-up/tabular, and greedy algorithms). I had a particular hard time with this aspect as I was not understanding how to recurse but I was able to meet with Dr. Boyd and further learn and implement these solutions to the homework. 

The homework problems were to create a memoized, tabular, and naive method for calculating the n-th Fibonacci term and then test our code for values [1, 40] and compare calculation times. I was able to get to the 2-millionth Fibonnaci number using my bottom-down approach where a deque was implemented. 

The last homework problem was to create a bottom-up and greedy approach to the minimal number of coins, in a given coin system, needed to complete a given amount of change (i.e. how many coins would be needed for a change of x-cents). I was able to produce a greedy algorithm as well as bottom up algorithm. We were not asked on memoization since that was a given example in the textbook. I did not work on returning the list of coins used since this was the problem I had troubles with that and cared more for understanding the concept of how to dynamically program theses and work on that and then if I had time afterwards comeback and implement the second half. 

### HW4_5 (Vol 2)
This algorithm was intended to solve a {0,1} (that is either you take one or zero of an item) knapsack problem of n-items with given weights (w1,...,wn) and values (v1,...,vn). The code returns the maximum number of items that can be placed into the knapsack given a weight limit W. I had fun working on this logic. It was rather difficult, but I was able to help others learn from my example since I coded the problem with the guidance of the TA in just ensuring I was incorporating all cases. The code does assume that the given items will be unique, so there are no repeats. I was going to account for possible repeats of an item (with a different weight) but the autograder only needed the case for unique items. 



### Binary Search Trees

I very much enjoyed this lab. The lab was intended to help me learn to code a BST tree using some recursive techniques for searching and inserting nodes. It also helped me learn the difference in time complexities of BST vs. AVL vs. Singly Linked Lists. This one tested more of my knowledge about programming thus far as well as comprehension of recursion. I received a 50/50